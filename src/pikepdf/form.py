from contextlib import contextmanager
from decimal import Decimal
from pikepdf import Dictionary, Pdf, Rectangle, Matrix, Name, Operator, parse_content_stream
from pikepdf._core import AcroForm, AcroFormField, FormFieldFlag
from pikepdf.canvas import ContentStreamBuilder, EmbeddedFont, Font
from typing import Mapping, Tuple

class Form:
    """Utility class to make it easier to work with interactive forms.

    This is easier to use than the core `pikepdf.AcroForm` implementation, but is higher-
    level, and abstracts over details in ways which do impose some limitations, such as 
    failing for PDFs which have multiple fields with the same name.

    In addition to ease of use, this also provides a mechanism for generating appearance
    streams which can sometimes produce better results than the normal QDPF implementation.
    """
    generate_appearances: bool
    """If True, appearance streams will be generated by pikepdf whenever you use this 
    object to update form values. If false, the PDF's ``need_appearances`` flag will be 
    set to True.

    This uses a different algorithm for building appearance streams than the
    `pikepdf.AcroForm.generate_appearances_if_needed` method or the 
    `pikepdf.Pdf.generate_appearance_streams` method, both of which use the underlying
    QPDF implementation.
    """
    ignore_max_length: bool
    """If True, we will ignore the MaxLen property of any text fields in this form. This
    produces a PDF that would typically not be possible to create in an interactive PDF
    reader, but this may be desirable or useful if the PDF is intended to be read by 
    another automated system rather than a human.
    """
    _pdf: Pdf
    _acroform: AcroForm
    _cache: Mapping['_FieldWrapper']

    def __init__(self, pdf: Pdf, generate_appearances:bool = True, *, ignore_max_length = False):
        self._pdf = pdf
        self._acroform = pdf.acroform
        self._cache = {}
        self.generate_appearances = generate_appearances
        self.ignore_max_length = ignore_max_length
    
    def __getitem__(self, name: str):
        if name in self._cache:
            return self._cache[name]
        fields = self._acroform.get_fields_with_qualified_name(name)
        if not fields:
            raise KeyError(name)
        if len(fields) > 1:
            raise RuntimeError(f'Multiple fields with same name: {name}')
        return self._wrap(fields[0], name)
    
    def __contains__(self, name: str):
        try:
            self.__getitem__(name)
            return True
        except KeyError:
            return False
    
    def items(self):
        seen = set()
        for field in self._acroform.fields:
            name = field.fully_qualified_name
            if name in self._cache and name not in seen:
                seen.add(name)
                yield name, self._cache[name]
            elif name in self._cache and not (field.is_radio_button and field.parent == self._cache[name]._field):
                raise RuntimeError(f'Multiple fields with same name: {name}')
            elif field.is_radio_button:
                # QPDF does something here which is perhaps not entirely correct by the 
                # spec, and which causes issues. By the spec, a radio button group is a 
                # single field with multiple widget annotations in the Kids array. (See 
                # 12.7.5.2.4 of the 2.0 spec) However, QPDF here treats is as a group 
                # containing separate terminal fields for each button, each inheriting 
                # the same name. Fortunately, the implementation of 
                # `get_fields_with_qualified_name` seems to be correct, so we'll fall 
                # back to using that.
                fields = self._acroform.get_fields_with_qualified_name(name)
                if len(fields) > 1:
                    raise RuntimeError(f'Multiple fields with same name: {name}')
                seen.add(name)
                yield name, self._wrap(fields[0], name)
            else:
                seen.add(name)
                yield name, self._wrap(field, name)
    

    def __iter__(self):
        for name, item in self.items():
            yield item

    
    def _wrap(self, field: AcroFormField, name: str):
        field = field.top_level_field
        if field.is_text:
            wrapped = TextField(self, field)
        elif field.is_checkbox:
            wrapped = CheckboxField(self, field)
        elif field.is_radio_button:
            wrapped = RadioButtonGroup(self, field)
        elif field.is_pushbutton:
            wrapped = PushbuttonField(self, field)
        elif field.is_choice:
            wrapped = ChoiceField(self, field)
        else:
            raise RuntimeError('Unknown field type')
        self._cache[name] = wrapped
        return wrapped


class _FieldWrapper:
    def __init__(self, form: Form, field: AcroFormField):
        self._form = form
        self._field = field

    def __getattr__(self, name):
        return getattr(self._field, name)
    
    @property
    def is_required(self) -> bool:
        """Is this a required field?"""
        return bool(self._field.flags & FormFieldFlag.required)
    
    @property
    def is_read_only(self) -> bool:
        """Is this a read-only field"""
        return bool(self._field.flags & FormFieldFlag.read_only)
    
    @property
    def export_enabled(self) -> bool:
        """Should the value of this field be included when exporting data from the PDF?"""
        return not self._field.flags & FormFieldFlag.no_export


class TextField(_FieldWrapper):
    @property
    def is_multiline(self) -> bool:
        """Is this a multiline text field?
        
        If True, text will be wrapped and newlines will be allowed. If False, text will
        not be wrapped and newlines are stripped.
        """
        return bool(self._field.flags & FormFieldFlag.tx_multiline)
    
    @property
    def is_combed(self) -> bool:
        """Is this a combed text field?
        
        If True, the field will be split into equal-length segments, based on 
        ``max_length``, containing one character each.
        """
        return bool(self._field.flags & FormFieldFlag.tx_comb)
    
    @property
    def is_rich_text(self) -> bool:
        """Is this a rich text field?
        
        Rich text functionality is not currently implemented, but this flag is presented 
        for your information.
        """
        return bool(self._field.flags & FormFieldFlag.tx_rich_text)
    
    @property
    def is_password(self) -> bool:
        """Is this a password field?
        
        Password fields are not currently implemented, but this flag is presented for 
        your information.
        """
        return bool(self._field.flags & FormFieldFlag.tx_password)
    
    @property
    def is_file_select(self) -> bool:
        """Is this a file select field?
        
        File select fields are not currently implemented, but this flag is presented for 
        your information.
        """
        return bool(self._field.flags & FormFieldFlag.tx_file_select)
    
    @property
    def spell_check_enabled(self) -> bool:
        """Should spell-checking be enabled in this field?"""
        return not self._field.flags & FormFieldFlag.tx_do_not_spell_check
    
    @property
    def scrolling_enabled(self) -> bool:
        """Should scrolling (horizontal or vertical) be allowed in this field?"""
        return not self._field.flags & FormFieldFlag.tx_do_not_scroll
    
    @property
    def max_length(self) -> int | None:
        """The maximum length of the text in this field."""
        return self._field.get_inheritable_field_value(Name.MaxLen)
    
    @property
    def default_value(self) -> str:
        return self._field.default_value_as_string
    
    @property
    def value(self) -> str:
        return self._field.value_as_string
    
    @value.setter
    def value(self, value: str):
        # Coerce the value into something acceptable if it isn't
        if not self.is_multiline:
            value = value.replace('\n', '')
        max_length = self.max_length
        if not self._form.ignore_max_length and max_length is not None and len(value) > max_length:
            value = value[:max_length]
            # TODO emit warning
        # Set the value
        self._field.set_value(value, not self._form.generate_appearances)
        # Generate appearance streams if requested.
        if self._form.generate_appearances:
            if self.is_multiline:
                _text_appearance_multiline(self, value)
            else:
                # Fall back to the QPDF implementation if we don't have a better one
                self._field.generate_appearance()



class CheckboxField(_FieldWrapper):
    @property
    def checked(self) -> bool:
        value = self._field.value
        if value is None or value == Name.Off:
            return False
        else:
            return True
    
    @checked.setter
    def checked(self, checked: bool):
        ...


class RadioButtonGroup(_FieldWrapper):
    @property
    def options(self) -> Sequence[RadioButtonOption]:
        ...
    
    @property
    def selected_option(self) -> RadioButtonOption | None:
        ...


class RadioButtonOption:
    def select(self):
        ...
    ...


class PushbuttonField(_FieldWrapper):
    # Pushbutton fields are useless, so we won't attempt to do anything with them, but 
    # this is here for completeness.
    pass


class ChoiceField(_FieldWrapper):
    @property
    def options(self) -> Sequence[ChoiceFieldOption]:
        ...
    
    @property
    def selected_option(self) -> ChoiceFieldOption | None:
        ...


class ChoiceFieldOption:
    def select(self):
        ...
    ...


# The following functions are used to generate appearance streams for text inputs. With 
# some additional refinement, some of this functionality could be moved to the canvas 
# submodule and exposed as part of a public API.
#
# Generating appearance streams for text fields is not trivial. Section 12.7.4.3 of the 
# PDF 2.0 spec (Variable text) lays out how this is to be done. Also refer to the 
# following similar implementations for references:
#
# * https://github.com/py-pdf/pypdf/blob/5c3550f66c5da530eb8853da91afe0f942afcbef/pypdf/_writer.py#L857
# * https://github.com/mozilla/pdf.js/blob/2c87c4854a486d5cd0731b947dd622f8abe5e1b5/src/core/annotation.js#L2138
# * https://github.com/fwenzel/pdftk/blob/a3db40d1a43207eaad558aa9591ef81403b51616/java/pdftk/com/lowagie/text/pdf/AcroFields.java#L407
# * https://github.com/qpdf/qpdf/blob/81823f4032caefd1050bccb207d315839c1c48db/libqpdf/QPDFFormFieldObjectHelper.cc#L746
    

def _text_appearance_multiline(field: TextField, text: str):
    da, font, font_name, font_size, matrix = _decode_da(field)
    for annot in field._form._acroform.get_annotations_for_field(field._field):
        # There is likely only one annot, but we have to allow for multiple
        bbox = annot.rect.to_bbox()
        with _text_stream_builder(da) as cs:
            if matrix is None:
                cs.set_text_matrix(Matrix.identity)
            _layout_multiline_text(cs, text, font, font_size, bbox)
        # Convert content stream to a Form XObject and save in the annotation appearance 
        # dictionary (AP) under the normal (N) key.
        fonts_dict = Dictionary()
        fonts_dict[font_name] = font.register(field._form._pdf)
        resources = Dictionary(Font = fonts_dict)
        xobj = _create_form_xobject(field._form._pdf, bbox, cs, resources)
        if Name.AP in annot.obj:
            annot.obj.AP.N = xobj
        else:
            annot.obj.AP = Dictionary(N = xobj)


def _decode_da(field: TextField | ChoiceField) -> Tuple[bytes, Font, Name, Decimal, Matrix | None]:
    """Parse the default appearance, returning it and the font styling information.
    
    The default appearance is a value that is used to initialize the content stream for 
    text fields. It must at minimum contain a `Tf` operator, which indicates the font 
    family and size.
    """
    da = field.default_appearance
    tmp_pdf = Pdf.new()
    tmp_stream = tmp_pdf.make_stream(da)
    instructions = parse_content_stream(tmp_stream)
    # Locate the last Tf operator and use its operands (In theory there should only be 
    # one, but you never know...) Also locate the optional Tm operator.
    tf_op = Operator('Tf')
    tm_op = Operator('Tm')
    tf_inst = None
    tm_inst = None
    for inst in instructions:
        if inst.operator == tf_op:
            tf_inst = inst
        if inst.operator == tm_op:
            tm_inst = inst
    if tf_inst is None:
        # This state is not valid according to the spec, but for robustness we could 
        # consider adding a fallback.
        raise RuntimeError(f"No Tf operator found in default appearance stream for {field._field.fully_qualified_name}")
    # Load styling information from the DA
    font_family, font_size = tf_inst.operands
    font = EmbeddedFont.load(font_family, field._field.default_resources)
    matrix = tm_inst.operands[0] if tm_inst is not None else None
    return da, font, font_family, font_size, matrix


@contextmanager
def _text_stream_builder(da: bytes):
    """Utility to build text content streams for variable text fields.
    
    Example:

    .. code-block:: python

        with _text_stream_builder(da) as cs:
            # Make calls against cs, e.g.:
            cs.show_text(b'some text')
            ...
        
        # Now cs is complete. (Make sure you are outside the context manager; additional 
        # operations are added once the context manager closes.)
    """
    content_builder = ContentStreamBuilder()
    content_builder.begin_marked_content(Name.Tx)
    content_builder.push()
    # Adobe includes a re, E, and n operation here (Creating a clip rectangle). Many other 
    # PDF viewers do similarly. This is probably a good idea for the future, but for now, 
    # while the layout algorithm is still imperfect, there is probably value in not 
    # clipping and just showing what was entered.
    content_builder.begin_text()
    content_builder.extend(da)
    yield content_builder
    content_builder.end_text()
    content_builder.pop()
    content_builder.end_marked_content()


def _layout_multiline_text(content: ContentStreamBuilder, text: str, font: Font, font_size: Decimal, bbox: Rectangle):
    """Lay out the given text, wrapping at the edges of the bounding box.

    This layout algorithm is incomplete and somewhat rudimentary, but should produce
    acceptable results for most common use cases.

    Known issues:

    * Does not respect field-defined alignment (quadding) and spacing.
    * The text may overflow out the bottom of the box. We don't try to prevent this 
      currently, though a correct implementation would do so if scrolling was disabled.
    * Words which are longer than the box width may overflow out the right side.
    * Does not allow line breaks other than at ' ' or '\\n' characters.
    """
    # We render each word with a separate Td and Tj operator. This is how Adobe does it.
    # The PDF specification does include operators for showing entire lines of text with
    # a single operation. However, when viewed in some PDF viewers (e.g. Firefox's build=
    # in viewer) these operations do not apply proper spacing. All the words are smashed
    # together with no space in-between. This has the disadvantage of not respecting 
    # values that the DA string may have set for word spacing and line spacing; we are 
    # essentially hard-coding the spacing. But, if even Adobe does it this way, there's
    # probably a reason for it.
    word_spacing = font.text_width(' ', font_size)
    line_spacing = 10 # TODO calculate this value based on font
    width = bbox.width
    current_width = Decimal(0)
    for line in text.splitlines():
        last_width = Decimal(0)
        for word in line.split():
            word_len = font.text_width(word, font_size)
            if current_width + word_len > width:
                # Wrap if too long
                content.move_cursor(-current_width, -line_spacing)
                current_width = Decimal(0)
                last_width = Decimal(0)
            else:
                # Advance forward
                content.move_cursor(last_width, 0)
                current_width += last_width
                last_width = word_len + word_spacing
            content.show_text_string(font.encode(word+' '))


def _create_form_xobject(pdf: Pdf, bbox: Rectangle, content: ContentStreamBuilder, resources: Dictionary):
    """Convert a content stream into a Form XObject."""
    return pdf.make_stream(content.build(), 
            Type = 'XObject',
            Subtype = 'Form',
            FormType = 1,
            BBox = bbox,
            Resources = resources)
